---
title: "백준 11654번, 11720번, 10809번, 2675번"
date: "2021-10-28 17:33"
tag: "#백준알고리즘#javascript"
thumbnail: null
---

# 11654번 : 아스키코드

<br/>

## #문제

알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오.

<br/>

## #입력

알파벳 소문자, 대문자, 숫자 0-9 중 하나가 첫째 줄에 주어진다.

<br/>

## #출력

입력으로 주어진 글자의 아스키 코드 값을 출력한다.

<br/>

## #풀이

간단한 문제다. charCodeAt 을 이용하면 끝

```javascript
let fs = require('fs');
let input = fs.readFileSync('/dev/stdin').toString();

console.log(input.charCodeAt(0));
```

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

# 11720번 : 숫자의 합

<br/>

## #문제

N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.

<br/>

## #입력

첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.

<br/>

## #출력

입력으로 주어진 숫자 N개의 합을 출력한다.

<br/>

## #풀이

for문을 이용하면 간단히 풀 수 있는 문제이다. 근데 Array.prototype.reduce() 를 사용하면 다른 변수의 선언 없이도 간단하게 합을 구할 수 있다.

```javascript
arr.reduce(callback[, initialValue])
```

<br/>

### 매개변수

- callback : 배열의 각 요소에 대해 실행할 함수. 다음 네 가지 인수를 받습니다.

    1. accumulator : 콜백의 반환값을 누적합니다. 
    2. currentValue : 처리할 현재 요소.
    3. currentIndex (옵션) : 처리할 현재 요소의 인덱스. initialValue를 제공한 경우 0, 아니면 1부터 시작.
    4. array (옵션) : reduce() 를 호출한 배열.

- initialValue (옵션) : callback의 최초 호출에서 첫 번쨰 인수에 제공하는 값. 초기값을 제공하지 않으면 배열의 첫 번째 요소를 사용한다. 빈 배열에서 초기값 없이 reduce() 를 호출하면 오류가 발생한다.

<br/>

### 반환 값

누적 계산의 결과값

<br/>
<br/>

배열을 순회하면서 계산 결과값을 누적시킬 수 있다! 개꿀.....이 문제를 푸는데에 딱이다. 입력받은 숫자를 각 자리별로 나눈 배열에 대해 초기값 0으로 reduce() 를 실행시킨다.

```javascript
let fs = require('fs');
let input = fs.readFileSync('/dev/stdin').toString().split('\n');

let result = input[1].split('').reduce((accumulator, value) => {
    accumulator += parseInt(value);

    return accumulator;
}, 0);


console.log(result);
```

끝! 귀찮게 for문을 사용할 필요 없이, 다른 변수를 선언할 필요도 없이 한큐에 마무리~

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>


# 10809번 : 알파벳 찾기

<br/>

## #문제

알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.

<br/>

## #입력

첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.

<br/>

## #출력

각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치, ... z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.

만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다. 단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다.

<br/>

## #풀이

처음 등장하는 위치를 출력하는 문제. a에서 z까지 26개의 알파벳이 있으므로 길이 26인 배열을 생성하여 위치를 저장하면 끝! 나는 문제겠다.

무슨 알파벳인지 어떻게 알지? 우선 입력받은 각각의 요소에 접근해야하므로, map을 사용하였다. (사실 forEach가 더 적절할 것 같다.) 우선 위치를 저장할 배열을 

```javascript
let letters = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
```

앞에서부터 a, b, c, d,,,,,마지막이 z 의 위치를 저장할 배열이다. 자 이제 입력받은 숫자를 쪼개서 위치를 구해보자

무슨 알파벳인지 판별하는 것은 간단하다. 아스키코드로 변환한 후에 a의 아스키코드 값을 빼면? 그 알파벳의 아스키코드가 나오게 된다! 아스키코드가 알파벳 순서대로 배정되어 있기 때문에 이런식의 사용도 가능하다.

코드를 작성해보면

```javascript
data.split('').map((el, index) => {
    let loc = el.charCodeAt(0) - 'a'.charCodeAt(0);
    if (letters[loc] === -1) {
        letters[loc] = index;
    } 
});
```

여기서 data는 숫자 문자열이다. map으로 배열을 순회하는데, 해당 요소의 아스키코드 값에서 'a'의 아스키코드 값을 빼서 무슨 알파벳인지 구한 뒤, letters 배열에서 해당하는 알파벳의 값이 -1일 경우 해당 인덱스(위치)를 저장한다.

마지막으로 letters 배열을 출력만 하면 끝.

```javascript
function solution(data) {
    let letters = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    data.split('').map((el, index) => {
        let loc = el.charCodeAt(0) - 'a'.charCodeAt(0);
        if (letters[loc] === -1) {
            letters[loc] = index;
        } 
    });

    let str = ''
    for (let i = 0; i < letters.length; i++) {
        if(i !== letters.length - 1) str += letters[i] + ' ';
        else str += letters[i];
    }

    console.log(str);
}


let fs = require('fs');
let input = fs.readFileSync('/dev/stdin').toString();

solution(input);
```

이것도 간단했당

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

# 2675번 : 문자열 반복

<br/>

## #문제

문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. 즉, 첫 번째 문자를 R번 반복하고, 두 번째 문자를 R번 반복하는 식으로 P를 만들면 된다. S에는 QR Code "alphanumeric" 문자만 들어있다.

QR Code "alphanumeric" 문자는 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\$%*+-./: 이다.

<br/>

## #입력

첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 반복 횟수 R(1 ≤ R ≤ 8), 문자열 S가 공백으로 구분되어 주어진다. S의 길이는 적어도 1이며, 20글자를 넘지 않는다. 

<br/>

## #출력

각 테스트 케이스에 대해 P를 출력한다.

<br/>

## #풀이

문자열 반복. 문제에 주어진 문자열일 경우, 입력된 숫자만큼 반복시켜서 출력하기. 우선 조건에 맞는 문자열인지 판별해야 한다. alphanumeric 문자열을 선언하자

```javascript
const alphanumeric = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\$%*+-./:';
```

그리고 테스트 케이스 만큼 해당 동작을 반복해야 한다. 그리고 해당 케이스에서 alphanumeric 변수에 저장된 문자열에 있는 문자인지 검색 후, 조건에 맞는 문자면 반복시킨다.

```javascript
const testCase = parseInt(data[0]);

for (let i = 1; i <= testCase; i++) {
    const sp = data[i].split(' ');
    const repeat = sp[0];
    let result = '';

    sp[1].split('').forEach(el => {
        if (alphanumeric.indexOf(el) !== -1) {
            for (let j = 0; j < repeat; j++) {
                result += el;
            }
        }
    });

    console.log(result);
}
```

forEach로 해당 케이스의 문자열을 순회한다. 그리고 alphanumeric 에서 indexOf 를 이용하여 확인 후, -1이 아니면(= 조건에 맞는 문자열이면) 반복문을 사용하여 출력할 문자열에 추가한다.

이것도 간단~ 문자열은 잘 쪼개고, 잘 분류하면 끝인 것 같다. for, forEach, map, reduce를 상황에 맞게 적절하게 사용하면 수월수월한 구간인듯?